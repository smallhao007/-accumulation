# AOF日志

- 先写内存，在写日志。
![01](./assets/redis-05.jpg)

- AOF里记录的是Redis收到的每一条命令，这些命令是以文本形式保存的。
![02](./assets/redis-06.jpg)
- 我们以Redis收到“set testkey testvalue”命令后记录的日志为例，看看AOF日志的内容。其中，“*3”表示当前命令有三个部分，每部分都是由“$+数字”开头，后面紧跟着具体的命令、键或值。这里，“数字”表示这部分中的命令、键或值一共有多少字节。例如，“$3 set”表示这部分有3个字节，也就是“set”命令。
- 先执行后记录的好处：
1. 因为先执行，所以执行成功才会记录日志，减少了对日志格式的检查
2. 不会影响写日志而造成的影响，不会阻塞写操作
- 潜在风险：
1. 如果写日志时宕机，则会影响数据完整性
2. 执行-写日志-执行，如果写日志很慢，也会阻塞后面的执行
- AOF的三种写回策略：
![03](./assets/redis-07.jpg)
    这三种都有可能出现宕机而数据丢失的情况，分别根据场景选择，想要获得高性能，就选择No策略；如果想要得到高可靠性保证，就选择Always策略；如果允许数据有一点丢失，又希望性能别受太大影响的话，那么就选择Everysec策略。

- AOF重写机制  
  1. 
  当AOF文件过大，会产生性能问题，主要在于以下三个方面：一是，文件系统本身对文件大小有限制，无法保存过大的文件；二是，如果文件太大，之后再往里面追加命令记录的话，效率也会变低；三是，如果发生宕机，AOF中记录的命令要一个个被重新执行，用于故障恢复，如果日志文件太大，整个恢复过程就会非常缓慢，这就会影响到Redis的正常使用。  
  2. AOF重写机制就是在重写时，Redis根据数据库的现状创建一个新的AOF文件，也就是说，读取数据库中的所有键值对，然后对每一个键值对用一条命令记录它的写入。由于多次修改重写后只取最新的结果，所以日志大小会减少。  
  3. 和AOF日志由主线程写回不同，重写过程是由后台线程bgrewriteaof来完成的，这也是为了避免阻塞主线程，导致数据库性能下降。每次AOF重写时，Redis会先执行一个内存拷贝，用于重写；然后，使用两个日志保证在重写过程中，新写入的数据不会丢失。而且，因为Redis采用额外的线程进行数据重写，所以，这个过程并不会阻塞主线程。
  
   ![08](./assets/redis-08.jpg)




# RDB快照
  ![01](./assets/redis-rdb-01.jpg)
- 对哪些数据做快照？如何做快照？  
    Redis会使用bgsave对当前内存中的所有数据做快照，这个操作是子进程在后台完成的，这就允许主线程同时可以修改数据。
- 多久做一次快照？  
1. 如果频繁地执行全量快照，也会带来两方面的开销。

    一方面，频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环。

    另一方面，bgsave子进程需要通过fork操作从主线程创建出来。虽然，子进程在创建后不会再阻塞主线程，但是，fork这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长。如果频繁fork出bgsave子进程，这就会频繁阻塞主线程了。那么，有什么其他好方法吗？
2. 增量快照  
    Redis 4.0中提出了一个混合使用AOF日志和内存快照的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用AOF日志记录这期间的所有命令操作。

    这样一来，快照不用很频繁地执行，这就避免了频繁fork对主线程的影响。而且，AOF日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。
