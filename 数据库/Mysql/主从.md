# 主从库的设计

## 同步准则
![01](./../Redis/redis-zc-01.jpg)

## 第一次同步  
    当我们启动多个Redis实例的时候，它们相互之间就可以通过replicaof（Redis 5.0之前使用slaveof）命令形成主库和从库的关系，之后会按照三个阶段完成数据的第一次同步。  

    例如，现在有实例1（ip：172.16.19.3）和实例2（ip：172.16.19.5），我们在实例2上执行以下这个命令后，实例2就变成了实例1的从库，并从实例1上复制数据：
    ```
    replicaof  172.16.19.3  6379
    ```
## 同步流程
![02](./../Redis/redis-zc-02.jpg)

    在**第一阶段**是主从库间建立连接、协商同步的过程，主要是为全量复制做准备。在这一步，从库和主库建立起连接，并告诉主库即将进行同步，主库确认回复后，主从库间就可以开始同步了。  
      
    具体来说，从库给主库发送psync命令，表示要进行数据同步，主库根据这个命令的参数来启动复制。psync命令包含了主库的runID和复制进度offset两个参数。
  -  runID，是每个Redis实例启动时都会自动生成的一个随机ID，用来唯一标记这个实例。当从库和主库第一次复制时，因为不知道主库的runID，所以将runID设为“？”。
  -  offset，此时设为-1，表示第一次复制。

    主库收到psync命令后，会用FULLRESYNC响应命令带上两个参数：主库runID和主库目前的复制进度offset，返回给从库。从库收到响应后，会记录下这两个参数。  

    这里有个地方需要注意，FULLRESYNC响应表示第一次复制采用的全量复制，也就是说，主库会把当前所有的数据都复制给从库。

    在**第二阶段**，主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载。这个过程依赖于内存快照生成的RDB文件。

    具体来说，主库执行bgsave命令，生成RDB文件，接着将文件发给从库。从库接收到RDB文件后，会先清空当前数据库，然后加载RDB文件。这是因为从库在通过replicaof命令开始和主库同步前，可能保存了其他数据。为了避免之前数据的影响，从库需要先把当前数据库清空。

    在主库将数据同步给从库的过程中，主库不会被阻塞，仍然可以正常接收请求。否则，Redis的服务就被中断了。但是，这些请求中的写操作并没有记录到刚刚生成的RDB文件中。为了保证主从库的数据一致性，主库会在内存中用专门的replication buffer，记录RDB文件生成后收到的所有写操作。

    最后，也就是**第三个阶段**，主库会把第二阶段执行过程中新收到的写命令，再发送给从库。具体的操作是，当主库完成RDB文件发送后，就会把此时replication buffer中的修改操作发给从库，从库再重新执行这些操作。这样一来，主从库就实现同步了。

## 多个从库如何保证性能
- 通过“主-从-从”模式将主库生成RDB和传输RDB的压力，以级联的方式分散到从库上。
  
## 同步期间网络断了怎么处理
- 增量复制，正常情况主从通过长连接保持数据传输，减少连接的消耗，一旦网络断了，主库会重新向从库发起连接请求，从中断处重新发起同步。中断的内存数据保存在repl_backlog_buffer中，repl_backlog_buffer是一块环形缓存，要保证从库读的速度不能比主库写的速度慢太多，不然会覆盖未读区域，导致全量重新同步。

